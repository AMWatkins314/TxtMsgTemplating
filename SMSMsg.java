/*************************************************************************
* Author: Amanda Watkins
* Date: July 19th, 2016
* Program: SMSMsg.java
* Description: This program outputs  
* Usage: java SMSMsg <template_file> <token_mapping_file> <msgcount>
* Example Usage: java SMSMsg template_1.txt tokens.txt c=1 
* Required Input: template_file - the file containing the message template to use.
*                 token_mapping_file - the file containing the token-value mappings to substitute into the template. 
* Optional Input: The msgcount flag c=1 - specifying c=1 as the third argument causes the message count to be pre-pended to all sub-messages. 
*                 By default, the msgcount flag is off so no message counts are pre-pended to sub-messages.
* Output: A message is output as several sub-messages that are less than or equal to the SMSMsg MAX_LENGTH (which by default is 160 characters). 
*         The message is generated by replacing tokens in the template_file with their corresponding values from the token_mapping_file.
*         If the optional msgcount flag c=1 is specified then each sub-message is pre-pended with the current message count.
*************************************************************************/

import java.io.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.regex.Matcher;


public class SMSMsg {
   private ArrayList<String> template; 
   private HashMap<String, ArrayList<String>> tokens;

   /* Assumes that no one word in a message will be longer than MAX_LENGTH */
   private static int MAX_LENGTH = 160;

   public SMSMsg (ArrayList<String> template, HashMap<String, ArrayList<String>> tokens) {
      this.template = new ArrayList<String>(template.size());
      for(String str : template){
         this.template.add(new String(str));
      }
      this.tokens = new HashMap<String, ArrayList<String>>(); 
      this.tokens.putAll(tokens);
   } 


   private void output(Boolean prepend_msg_counter){
      /* Construct a complete message using the template and token-value mappings */
      ArrayList<String> msg = new ArrayList<String>(); 

      double char_cntr = 0.0;

      /* Remove all punctuation and whitespace characters when examining the template's current word */
      String delimiters = "[,;:.!?\\s]+";

      for(String word : this.template){
         String word_stripped = (word.split(delimiters))[0];
         String search_key = word_stripped.toLowerCase();
         if(this.tokens.containsKey(search_key)){
            /* If the current word in the calling SMSMsg object's template is a token then replace it with its values */
            ArrayList<String> token_values = this.tokens.get(search_key);
 
            ListIterator<String> iterator = token_values.listIterator();      
            while(iterator.hasNext()){
               String value = iterator.next();
               if(iterator.hasNext()){
                  /* One of two or more values */
                  value += "\n";
                  msg.add(value);
                  char_cntr += value.length();
               }
               else{
                  /* Last or only value so replace in word in case there was punctuation after it */
                  String last_value = word.replaceAll(word_stripped,value); 
                  msg.add(last_value); 
                  char_cntr += last_value.length();
               }
            }
         }
         else{
            /* Else the current word is just a regular word so keep it the same */ 
            msg.add(word);
            char_cntr += word.length();
         }
      }

      /* Output the message as sub-messages depending on MAX_LENGTH */
      if(!prepend_msg_counter) {
         /* Do not prepend the message counter to the sub-messages */
         /* Split the complete message into sub-messages of size less than MAX_LENGTH */
         ListIterator<String> iterator = msg.listIterator();
         ArrayList<String> all_messages = new ArrayList<String>();
         String curr_smsg = "";
         while(iterator.hasNext()){
           String word = iterator.next();
           if((curr_smsg.length() + word.length()) < this.MAX_LENGTH){
                 /* Add current word to the current sub-message since it will fit */
                 curr_smsg += word;
           } 
           else {
              /* Add the previous message to the ArrayList since the current word cannot be appended to it */
              all_messages.add(curr_smsg);

              /* The current word becomes the first word in the next sub-message */
              curr_smsg = new String(word);
           } 
         } 
         /* No more messages to process so add the current submessage to the all_messages ArrayList */
         all_messages.add(curr_smsg);

         /* Output each sub-message in messages */
         for(String smsg : all_messages){
            System.out.println(smsg);
         }
      }
      else{
         /* Prepend the message counter to each sub-message */
         String estimated_smsgs = (new Double( Math.ceil(char_cntr/(double)this.MAX_LENGTH))).toString();
        
         /* Prepended message counts look like: (1/2), (5/15), (10/10), etc. */
         /* prepend_cnt takes into account the total sub-message count's number of digits, */
         /* the three (/) characters, and an added space before the sub-message start */
         /* The current sub message number's digit count has to be added */
         int prepend_cnt = estimated_smsgs.substring(0, estimated_smsgs.indexOf('.')).length() + 4;
         
         ListIterator<String> iterator = msg.listIterator();
         ArrayList<String> all_messages = new ArrayList<String>();
         String curr_smsg = "";
         int iteration = 0;
         while(iterator.hasNext()){
           iteration++;
           int curr_cnt = String.valueOf(iteration).length(); 

           String word = iterator.next();
           if((curr_smsg.length() + word.length()) + prepend_cnt + curr_cnt < this.MAX_LENGTH){
                 /* Add current word to the current sub-message since it will fit */
                 curr_smsg += word;
           } 
           else {
              /* Add the previous message to the ArrayList since the current word cannot be appended to it */
              all_messages.add(curr_smsg);

              /* The current word becomes the first word in the next sub-message */
              curr_smsg = new String(word);
           } 
         } 
         /* No more messages to process so add the current submessage to the all_messages ArrayList */
         all_messages.add(curr_smsg);

         /* Output each sub-message in messages */
         int total = all_messages.size();
         int count = 1;
         for(String smsg : all_messages){
            System.out.println("(" + count + "/" + total + ") " + smsg);
            count++;
         }
      }

   }


   public static void main(String args[]) {
     if( (args.length == 2) || (args.length == 3) ){
        /* Read in the template file */
        ArrayList<String> template = readTemplate(args[0]); 

        /* Read in the token map file */
        HashMap<String, ArrayList<String>> tokens = readTokens(args[1]);

        /* Outputting message without pre-pended counters is the default behavior */
        Boolean prepend_msg_counter = false;

        if (args.length == 3){
           Pattern arg_p = Pattern.compile("[c|C]=1");
           Matcher arg_m = arg_p.matcher(args[2]);  
           prepend_msg_counter = arg_m.find() ? true : false;
        }

        /* Create the SMSMsg with the given template and token mappings */
        SMSMsg msg = new SMSMsg(template, tokens);  
 
        /* Output the SMSMsg */
        msg.output(prepend_msg_counter);
     } 
     else{
        /* Either there were too few or too many arguments given so output the usage message */
        System.out.println("Usage: `java SMSMsg <template_file> <token_mapping_file> <optional_msgcount>`"); 
        System.out.println("where <template_file> is the file containing the templated SMS message to send");
        System.out.println("and <token_mapping_file> is the file containing the mapping of tokens to use with the template file");
        System.out.println("and <optional_msgcount> is the optional argument c=1 which causes the message count to be pre-pended to each message");
     }
   }



   public static ArrayList<String> readTemplate(String template_filepath){
      ArrayList<String> template = new ArrayList<String>();

      try{
         /* Read the template file */
         Scanner fs = new Scanner(new File(template_filepath));

         while(fs.hasNext()){
            String line = fs.nextLine();
         
            /* Split on whitespace */ 
            String[] words = line.split("\\s+");

            /* Add each space separated word in the current line to the ArrayList */
            /* Append the trailing spaces back in after each word that is not last */
            for(int i=0; i<words.length-1; i++){
               template.add(words[i] + " ");
            }
            /* Add the newline back to the end of the line to preserve template formatting */
            template.add(words[words.length-1] + '\n');
         } 
         /* Close the template file scanner */
         fs.close();
      }
      catch(FileNotFoundException e){
         System.out.println("Usage: `java SMSMsg <template_file> <token_mapping_file> <optional_msgcount>`"); 
         System.out.println("Error reading <template_file>");
      }
      return template;
   }



   public static HashMap<String, ArrayList<String>> readTokens(String tokenmap_filepath){
      HashMap<String, ArrayList<String>> tokens = new HashMap<String, ArrayList<String>>();

      try{
         /* Read the token mapping file */
         Scanner fs = new Scanner(new File(tokenmap_filepath));

         while(fs.hasNext()){
            String line = fs.nextLine();
         
            /* Note: The unique key is the first string and subsequent strings are the key's values */
            String delimiters = "[:,\\{\\}]";
            String[] keyvalsmap = line.split(delimiters);

            String quoted_key = keyvalsmap[1].trim();
            String key = quoted_key.substring(1, quoted_key.length()-1);
            ArrayList<String> values = new ArrayList<String>();
            for(int i=2; i<keyvalsmap.length; i++){
               String quoted_value = keyvalsmap[i].trim();
               String value = quoted_value.substring(1, quoted_value.length()-1);
               values.add(value);
            }
            tokens.put(key.toLowerCase(), values);
         } 
         /* Close the token mapping file scanner */
         fs.close();
      }
      catch(FileNotFoundException e){
         System.out.println("Usage: `java SMSMsg <template_file> <token_mapping_file> <optional_msgcount>`"); 
         System.out.println("Error reading <token_mapping_file>");
      }
      return tokens;
   }


}
